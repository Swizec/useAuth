{"version":3,"file":"auth0.js","sources":["../src/providers/auth0.ts"],"sourcesContent":["import {\n    Auth0DecodedHash,\n    Auth0Error,\n    Auth0ParseHashError,\n    Auth0UserProfile,\n    AuthOptions as Auth0Options,\n    WebAuth\n} from \"auth0-js\";\nimport {\n    AuthOptions,\n    AuthProviderClass,\n    AuthUser,\n    ProviderOptions\n} from \"../types\";\n\n// Wrapper that provides a common interface for different providers\n// Modeled after Auth0 because that was first :)\nexport class Auth0 implements AuthProviderClass {\n    private auth0: WebAuth;\n    private dispatch: (eventName: string, eventData?: any) => void;\n    private customPropertyNamespace?: string;\n\n    constructor(params: AuthOptions) {\n        this.dispatch = params.dispatch;\n        this.customPropertyNamespace = params.customPropertyNamespace;\n\n        this.auth0 = new WebAuth({\n            ...(params as Auth0Options)\n        });\n    }\n\n    // Makes configuration easier by guessing default options\n    static addDefaultParams(params: ProviderOptions, callbackDomain: string) {\n        const vals = params as Auth0Options;\n\n        return {\n            redirectUri: `${callbackDomain}/auth0_callback`,\n            audience: `https://${vals.domain}/api/v2/`,\n            responseType: \"token id_token\",\n            scope: \"openid profile email\",\n            ...vals\n        };\n    }\n\n    // Opens login dialog\n    public authorize() {\n        this.auth0.authorize();\n    }\n\n    // Opens signup dialog\n    public signup() {\n        this.auth0.authorize({\n            mode: \"signUp\",\n            screen_hint: \"signup\"\n        });\n    }\n\n    // Logs user out on the underlying service\n    public logout(returnTo?: string) {\n        this.auth0.logout({ returnTo });\n    }\n\n    // Returns the userId from Auth0 shape of data\n    public userId(user: Auth0UserProfile): string {\n        return user.sub;\n    }\n\n    // Returns user roles from Auth0 shape of data\n    public userRoles(user: AuthUser): string[] | null {\n        const metadata =\n            user[\n                // make this friendlier to use if you leave a trailing slash in config\n                `${this.customPropertyNamespace}/user_metadata`.replace(\n                    /\\/+user_metadata/,\n                    \"/user_metadata\"\n                )\n            ];\n\n        return metadata?.roles || null;\n    }\n\n    // Handles login after redirect back from service\n    public async handleLoginCallback(): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            this.auth0.parseHash(\n                async (\n                    err: Auth0ParseHashError | null,\n                    authResult: Auth0DecodedHash | null\n                ) => {\n                    if (err) {\n                        this.dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"authResult\"\n                        });\n                        resolve(false);\n                    }\n\n                    try {\n                        const loggedIn = await this.handleAuthResult(\n                            authResult\n                        );\n\n                        resolve(loggedIn);\n                    } catch (err) {\n                        this.dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"handleAuth\"\n                        });\n                        resolve(false);\n                    }\n                }\n            );\n        });\n    }\n\n    // verifies session is still valid\n    // returns fresh user info\n    public async checkSession(): Promise<{\n        user: Auth0UserProfile;\n        authResult: Auth0DecodedHash;\n    }> {\n        return new Promise((resolve, reject) => {\n            this.auth0.checkSession(\n                {},\n                async (err: any, authResult: Auth0DecodedHash) => {\n                    if (\n                        !err &&\n                        authResult &&\n                        authResult.accessToken &&\n                        authResult.idToken\n                    ) {\n                        // fetch user data\n                        try {\n                            const user = await this.fetchUser(authResult);\n\n                            resolve({\n                                user,\n                                authResult\n                            });\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        reject(err || new Error(\"Session invalid\"));\n                    }\n                }\n            );\n        });\n    }\n\n    // Parses auth result and dispatches the AUTHENTICATED event\n    private async handleAuthResult(authResult: Auth0DecodedHash | null) {\n        if (authResult && authResult.accessToken && authResult.idToken) {\n            const user = await this.fetchUser(authResult);\n\n            this.dispatch(\"AUTHENTICATED\", {\n                authResult,\n                user\n            });\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Fetches current user info\n    private async fetchUser(\n        authResult: Auth0DecodedHash | null\n    ): Promise<Auth0UserProfile> {\n        return new Promise((resolve, reject) => {\n            this.auth0.client.userInfo(\n                authResult?.accessToken || \"\",\n                (err: Auth0Error | null, user: Auth0UserProfile) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(user);\n                    }\n                }\n            );\n        });\n    }\n}\n"],"names":["params","this","dispatch","customPropertyNamespace","auth0","WebAuth","Auth0","addDefaultParams","callbackDomain","redirectUri","audience","domain","responseType","scope","authorize","signup","mode","screen_hint","logout","returnTo","userId","user","sub","userRoles","metadata","replace","roles","handleLoginCallback","Promise","resolve","reject","_this2","parseHash","err","authResult","error","errorType","handleAuthResult","loggedIn","checkSession","_this4","accessToken","idToken","fetchUser","e","Error","_this6","_this8","client","userInfo"],"mappings":"yVAsBI,WAAYA,GACRC,KAAKC,SAAWF,EAAOE,SACvBD,KAAKE,wBAA0BH,EAAOG,wBAEtCF,KAAKG,MAAQ,IAAIC,eACTL,IAVhBM,EAeWC,iBAAP,SAAwBP,EAAyBQ,GAG7C,UACIC,YAAgBD,oBAChBE,oBAJSV,EAIiBW,kBAC1BC,aAAc,iBACdC,MAAO,wBANEb,+BAYVc,UAAA,WACHb,KAAKG,MAAMU,eAIRC,OAAA,WACHd,KAAKG,MAAMU,UAAU,CACjBE,KAAM,SACNC,YAAa,cAKdC,OAAA,SAAOC,GACVlB,KAAKG,MAAMc,OAAO,CAAEC,SAAAA,OAIjBC,OAAA,SAAOC,GACV,OAAOA,EAAKC,OAITC,UAAA,SAAUF,GACb,IAAMG,EACFH,GAEOpB,KAAKE,0CAAwCsB,QAC5C,mBACA,mBAIZ,aAAOD,SAAAA,EAAUE,QAAS,QAIjBC,yCAEL1B,KADJ,uBAAO,IAAI2B,QAAQ,SAACC,EAASC,GACzBC,EAAK3B,MAAM4B,mBAEHC,EACAC,OAEID,IACAF,EAAK7B,SAAS,QAAS,CACnBiC,MAAOF,EACPG,UAAW,eAEfP,GAAQ,8CAIeE,EAAKM,iBACxBH,kBADEI,GAINT,EAAQS,eACHL,GACLF,EAAK7B,SAAS,QAAS,CACnBiC,MAAOF,EACPG,UAAW,eAEfP,GAAQ,mEAxBpB,wCAnEZ,sCAoGiBU,kCAKLtC,KADJ,uBAAO,IAAI2B,QAAQ,SAACC,EAASC,GACzBU,EAAKpC,MAAMmC,aACP,YACON,EAAUC,4BAERD,GACDC,GACAA,EAAWO,aACXP,EAAWQ,mDAIYF,EAAKG,UAAUT,kBAA5Bb,GAENQ,EAAQ,CACJR,KAAAA,EACAa,WAAAA,gBAECU,GACLd,EAAOc,mDAGXd,EAAOG,GAAO,IAAIY,MAAM,qFArBpC,wCAzGZ,sCAsIkBR,0BAAiBH,aAEJjC,KADvB,OAAIiC,GAAcA,EAAWO,aAAeP,EAAWQ,wBAChCI,EAAKH,UAAUT,kBAA5Bb,GAON,OALAyB,EAAK5C,SAAS,gBAAiB,CAC3BgC,WAAAA,EACAb,KAAAA,0BAKG,GAjJnB,sCAsJkBsB,mBACVT,aAGIjC,KADJ,uBAAO,IAAI2B,QAAQ,SAACC,EAASC,GACzBiB,EAAK3C,MAAM4C,OAAOC,gBACdf,SAAAA,EAAYO,cAAe,GAC3B,SAACR,EAAwBZ,GACjBY,EACAH,EAAOG,GAEPJ,EAAQR,QAhKhC"}