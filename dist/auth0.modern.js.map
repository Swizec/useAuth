{"version":3,"file":"auth0.modern.js","sources":["../src/providers/auth0.ts"],"sourcesContent":["import {\n    Auth0DecodedHash,\n    Auth0Error,\n    Auth0ParseHashError,\n    Auth0UserProfile,\n    AuthOptions as Auth0Options,\n    WebAuth\n} from \"auth0-js\";\nimport {\n    AuthOptions,\n    AuthProviderClass,\n    AuthUser,\n    ProviderOptions\n} from \"../types\";\n\n// Wrapper that provides a common interface for different providers\n// Modeled after Auth0 because that was first :)\nexport class Auth0 implements AuthProviderClass {\n    private auth0: WebAuth;\n    private dispatch: (eventName: string, eventData?: any) => void;\n    private customPropertyNamespace?: string;\n\n    constructor(params: AuthOptions) {\n        this.dispatch = params.dispatch;\n        this.customPropertyNamespace = params.customPropertyNamespace;\n\n        this.auth0 = new WebAuth({\n            ...(params as Auth0Options)\n        });\n    }\n\n    // Makes configuration easier by guessing default options\n    static addDefaultParams(params: ProviderOptions, callbackDomain: string) {\n        const vals = params as Auth0Options;\n\n        return {\n            redirectUri: `${callbackDomain}/auth0_callback`,\n            audience: `https://${vals.domain}/api/v2/`,\n            responseType: \"token id_token\",\n            scope: \"openid profile email\",\n            ...vals\n        };\n    }\n\n    // Opens login dialog\n    public authorize() {\n        this.auth0.authorize();\n    }\n\n    // Opens signup dialog\n    public signup() {\n        this.auth0.authorize({\n            mode: \"signUp\",\n            screen_hint: \"signup\"\n        });\n    }\n\n    // Logs user out on the underlying service\n    public logout(returnTo?: string) {\n        this.auth0.logout({ returnTo });\n    }\n\n    // Returns the userId from Auth0 shape of data\n    public userId(user: Auth0UserProfile): string {\n        return user.sub;\n    }\n\n    // Returns user roles from Auth0 shape of data\n    public userRoles(user: AuthUser): string[] | null {\n        const metadata =\n            user[\n                // make this friendlier to use if you leave a trailing slash in config\n                `${this.customPropertyNamespace}/user_metadata`.replace(\n                    /\\/+user_metadata/,\n                    \"/user_metadata\"\n                )\n            ];\n\n        return metadata?.roles || null;\n    }\n\n    // Handles login after redirect back from service\n    public async handleLoginCallback(): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            this.auth0.parseHash(\n                async (\n                    err: Auth0ParseHashError | null,\n                    authResult: Auth0DecodedHash | null\n                ) => {\n                    if (err) {\n                        this.dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"authResult\"\n                        });\n                        resolve(false);\n                    }\n\n                    try {\n                        const loggedIn = await this.handleAuthResult(\n                            authResult\n                        );\n\n                        resolve(loggedIn);\n                    } catch (err) {\n                        this.dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"handleAuth\"\n                        });\n                        resolve(false);\n                    }\n                }\n            );\n        });\n    }\n\n    // verifies session is still valid\n    // returns fresh user info\n    public async checkSession(): Promise<{\n        user: Auth0UserProfile;\n        authResult: Auth0DecodedHash;\n    }> {\n        return new Promise((resolve, reject) => {\n            this.auth0.checkSession(\n                {},\n                async (err: any, authResult: Auth0DecodedHash) => {\n                    if (\n                        !err &&\n                        authResult &&\n                        authResult.accessToken &&\n                        authResult.idToken\n                    ) {\n                        // fetch user data\n                        try {\n                            const user = await this.fetchUser(authResult);\n\n                            resolve({\n                                user,\n                                authResult\n                            });\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        reject(err || new Error(\"Session invalid\"));\n                    }\n                }\n            );\n        });\n    }\n\n    // Parses auth result and dispatches the AUTHENTICATED event\n    private async handleAuthResult(authResult: Auth0DecodedHash | null) {\n        if (authResult && authResult.accessToken && authResult.idToken) {\n            const user = await this.fetchUser(authResult);\n\n            this.dispatch(\"AUTHENTICATED\", {\n                authResult,\n                user\n            });\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Fetches current user info\n    private async fetchUser(\n        authResult: Auth0DecodedHash | null\n    ): Promise<Auth0UserProfile> {\n        return new Promise((resolve, reject) => {\n            this.auth0.client.userInfo(\n                authResult?.accessToken || \"\",\n                (err: Auth0Error | null, user: Auth0UserProfile) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(user);\n                    }\n                }\n            );\n        });\n    }\n}\n"],"names":["Auth0","constructor","params","this","dispatch","customPropertyNamespace","auth0","WebAuth","[object Object]","callbackDomain","redirectUri","audience","domain","responseType","scope","authorize","signup","mode","screen_hint","logout","returnTo","userId","user","sub","userRoles","metadata","replace","roles","Promise","resolve","reject","parseHash","async","err","authResult","_this","error","errorType","loggedIn","handleAuthResult","checkSession","accessToken","idToken","_this2","fetchUser","e","Error","client","userInfo"],"mappings":"wPAiBaA,EAKTC,YAAYC,GACRC,KAAKC,SAAWF,EAAOE,SACvBD,KAAKE,wBAA0BH,EAAOG,wBAEtCF,KAAKG,MAAQ,IAAIC,OACTL,IAKZM,wBAAwBN,EAAyBO,GAG7C,UACIC,eAAgBD,mBAChBE,oBAJST,EAIiBU,iBAC1BC,aAAc,iBACdC,MAAO,wBANEZ,GAYVa,YACHZ,KAAKG,MAAMS,YAIRC,SACHb,KAAKG,MAAMS,UAAU,CACjBE,KAAM,SACNC,YAAa,WAKdC,OAAOC,GACVjB,KAAKG,MAAMa,OAAO,CAAEC,SAAAA,IAIjBC,OAAOC,GACV,OAAOA,EAAKC,IAITC,UAAUF,GACb,MAAMG,EACFH,KAEOnB,KAAKE,wCAAwCqB,QAC5C,mBACA,mBAIZ,aAAOD,SAAAA,EAAUE,QAAS,KAIvBnB,uCACH,WAAWoB,QAAQ,CAACC,EAASC,KACzB3B,KAAKG,MAAMyB,UACPC,eACIC,EACAC,GAEID,IACAE,EAAK/B,SAAS,QAAS,CACnBgC,MAAOH,EACPI,UAAW,eAEfR,GAAQ,IAGZ,IACI,MAAMS,QAAiBH,EAAKI,iBACxBL,GAGJL,EAAQS,GACV,MAAOL,GACLE,EAAK/B,SAAS,QAAS,CACnBgC,MAAOH,EACPI,UAAW,eAEfR,GAAQ,QASrBrB,gCAIH,WAAWoB,QAAQ,CAACC,EAASC,KACzB3B,KAAKG,MAAMkC,aACP,GACAR,eAAOC,EAAUC,GACb,IACKD,GACDC,GACAA,EAAWO,aACXP,EAAWQ,QAGX,IACI,MAAMpB,QAAaqB,EAAKC,UAAUV,GAElCL,EAAQ,CACJP,KAAAA,EACAY,WAAAA,IAEN,MAAOW,GACLf,EAAOe,QAGXf,EAAOG,GAAO,IAAIa,MAAM,wBAQpCtC,uBAAuB0B,GAC3B,GAAIA,GAAcA,EAAWO,aAAeP,EAAWQ,QAAS,CAC5D,MAAMpB,aAAkBsB,UAAUV,GAOlC,OALA/B,KAAKC,SAAS,gBAAiB,CAC3B8B,WAAAA,EACAZ,KAAAA,OAKJ,SAKAd,gBACJ0B,GAEA,WAAWN,QAAQ,CAACC,EAASC,KACzB3B,KAAKG,MAAMyC,OAAOC,gBACdd,SAAAA,EAAYO,cAAe,GAC3B,CAACR,EAAwBX,KACjBW,EACAH,EAAOG,GAEPJ,EAAQP"}